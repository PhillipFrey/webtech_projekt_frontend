{
  "version": 3,
  "sources": ["../../geotiff/dist-module/predictor.js", "../../geotiff/dist-module/compression/basedecoder.js"],
  "sourcesContent": ["function decodeRowAcc(row, stride) {\r\n  let length = row.length - stride;\r\n  let offset = 0;\r\n  do {\r\n    for (let i = stride; i > 0; i--) {\r\n      row[offset + stride] += row[offset];\r\n      offset++;\r\n    }\r\n\r\n    length -= stride;\r\n  } while (length > 0);\r\n}\r\n\r\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\r\n  let index = 0;\r\n  let count = row.length;\r\n  const wc = count / bytesPerSample;\r\n\r\n  while (count > stride) {\r\n    for (let i = stride; i > 0; --i) {\r\n      row[index + stride] += row[index];\r\n      ++index;\r\n    }\r\n    count -= stride;\r\n  }\r\n\r\n  const copy = row.slice();\r\n  for (let i = 0; i < wc; ++i) {\r\n    for (let b = 0; b < bytesPerSample; ++b) {\r\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\r\n    }\r\n  }\r\n}\r\n\r\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\r\n  planarConfiguration) {\r\n  if (!predictor || predictor === 1) {\r\n    return block;\r\n  }\r\n\r\n  for (let i = 0; i < bitsPerSample.length; ++i) {\r\n    if (bitsPerSample[i] % 8 !== 0) {\r\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\r\n    }\r\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\r\n      throw new Error('When decoding with predictor, all samples must have the same size.');\r\n    }\r\n  }\r\n\r\n  const bytesPerSample = bitsPerSample[0] / 8;\r\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\r\n\r\n  for (let i = 0; i < height; ++i) {\r\n    // Last strip will be truncated if height % stripHeight != 0\r\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\r\n      break;\r\n    }\r\n    let row;\r\n    if (predictor === 2) { // horizontal prediction\r\n      switch (bitsPerSample[0]) {\r\n        case 8:\r\n          row = new Uint8Array(\r\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\r\n          );\r\n          break;\r\n        case 16:\r\n          row = new Uint16Array(\r\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\r\n          );\r\n          break;\r\n        case 32:\r\n          row = new Uint32Array(\r\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\r\n          );\r\n          break;\r\n        default:\r\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\r\n      }\r\n      decodeRowAcc(row, stride, bytesPerSample);\r\n    } else if (predictor === 3) { // horizontal floating point\r\n      row = new Uint8Array(\r\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\r\n      );\r\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\r\n    }\r\n  }\r\n  return block;\r\n}\r\n", "import { applyPredictor } from '../predictor.js';\r\n\r\nexport default class BaseDecoder {\r\n  async decode(fileDirectory, buffer) {\r\n    const decoded = await this.decodeBlock(buffer);\r\n    const predictor = fileDirectory.Predictor || 1;\r\n    if (predictor !== 1) {\r\n      const isTiled = !fileDirectory.StripOffsets;\r\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\r\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\r\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\r\n      );\r\n      return applyPredictor(\r\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\r\n        fileDirectory.PlanarConfiguration,\r\n      );\r\n    }\r\n    return decoded;\r\n  }\r\n}\r\n"],
  "mappings": ";AAAA,SAAS,aAAa,KAAK,QAAQ;AACjC,MAAI,SAAS,IAAI,SAAS;AAC1B,MAAI,SAAS;AACb,KAAG;AACD,aAAS,IAAI,QAAQ,IAAI,GAAG,KAAK;AAC/B,UAAI,SAAS,MAAM,KAAK,IAAI,MAAM;AAClC;AAAA,IACF;AAEA,cAAU;AAAA,EACZ,SAAS,SAAS;AACpB;AAEA,SAAS,uBAAuB,KAAK,QAAQ,gBAAgB;AAC3D,MAAI,QAAQ;AACZ,MAAI,QAAQ,IAAI;AAChB,QAAM,KAAK,QAAQ;AAEnB,SAAO,QAAQ,QAAQ;AACrB,aAAS,IAAI,QAAQ,IAAI,GAAG,EAAE,GAAG;AAC/B,UAAI,QAAQ,MAAM,KAAK,IAAI,KAAK;AAChC,QAAE;AAAA,IACJ;AACA,aAAS;AAAA,EACX;AAEA,QAAM,OAAO,IAAI,MAAM;AACvB,WAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,aAAS,IAAI,GAAG,IAAI,gBAAgB,EAAE,GAAG;AACvC,UAAK,iBAAiB,IAAK,CAAC,IAAI,MAAO,iBAAiB,IAAI,KAAK,KAAM,CAAC;AAAA,IAC1E;AAAA,EACF;AACF;AAEO,SAAS,eAAe,OAAO,WAAW,OAAO,QAAQ,eAC9D,qBAAqB;AACrB,MAAI,CAAC,aAAa,cAAc,GAAG;AACjC,WAAO;AAAA,EACT;AAEA,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,EAAE,GAAG;AAC7C,QAAI,cAAc,CAAC,IAAI,MAAM,GAAG;AAC9B,YAAM,IAAI,MAAM,sEAAsE;AAAA,IACxF;AACA,QAAI,cAAc,CAAC,MAAM,cAAc,CAAC,GAAG;AACzC,YAAM,IAAI,MAAM,oEAAoE;AAAA,IACtF;AAAA,EACF;AAEA,QAAM,iBAAiB,cAAc,CAAC,IAAI;AAC1C,QAAM,SAAS,wBAAwB,IAAI,IAAI,cAAc;AAE7D,WAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAE/B,QAAI,IAAI,SAAS,QAAQ,kBAAkB,MAAM,YAAY;AAC3D;AAAA,IACF;AACA,QAAI;AACJ,QAAI,cAAc,GAAG;AACnB,cAAQ,cAAc,CAAC,GAAG;AAAA,QACxB,KAAK;AACH,gBAAM,IAAI;AAAA,YACR;AAAA,YAAO,IAAI,SAAS,QAAQ;AAAA,YAAgB,SAAS,QAAQ;AAAA,UAC/D;AACA;AAAA,QACF,KAAK;AACH,gBAAM,IAAI;AAAA,YACR;AAAA,YAAO,IAAI,SAAS,QAAQ;AAAA,YAAgB,SAAS,QAAQ,iBAAiB;AAAA,UAChF;AACA;AAAA,QACF,KAAK;AACH,gBAAM,IAAI;AAAA,YACR;AAAA,YAAO,IAAI,SAAS,QAAQ;AAAA,YAAgB,SAAS,QAAQ,iBAAiB;AAAA,UAChF;AACA;AAAA,QACF;AACE,gBAAM,IAAI,MAAM,gCAAgC,cAAc,CAAC,CAAC,mBAAmB;AAAA,MACvF;AACA,mBAAa,KAAK,QAAQ,cAAc;AAAA,IAC1C,WAAW,cAAc,GAAG;AAC1B,YAAM,IAAI;AAAA,QACR;AAAA,QAAO,IAAI,SAAS,QAAQ;AAAA,QAAgB,SAAS,QAAQ;AAAA,MAC/D;AACA,6BAAuB,KAAK,QAAQ,cAAc;AAAA,IACpD;AAAA,EACF;AACA,SAAO;AACT;;;ACrFA,IAAqB,cAArB,MAAiC;AAAA,EAC/B,MAAM,OAAO,eAAe,QAAQ;AAClC,UAAM,UAAU,MAAM,KAAK,YAAY,MAAM;AAC7C,UAAM,YAAY,cAAc,aAAa;AAC7C,QAAI,cAAc,GAAG;AACnB,YAAM,UAAU,CAAC,cAAc;AAC/B,YAAM,YAAY,UAAU,cAAc,YAAY,cAAc;AACpE,YAAM,aAAa,UAAU,cAAc,aACzC,cAAc,gBAAgB,cAAc;AAE9C,aAAO;AAAA,QACL;AAAA,QAAS;AAAA,QAAW;AAAA,QAAW;AAAA,QAAY,cAAc;AAAA,QACzD,cAAc;AAAA,MAChB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;",
  "names": []
}
