import "./chunk-5WWUZCGV.js";

// node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js
var edgeIntersectsEdge = function edgeIntersectsEdge2(a1, a2, b1, b2) {
  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);
  if (uB !== 0) {
    var ua = uaT / uB;
    var ub = ubT / uB;
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return true;
    }
  }
  return false;
};
var coordinatesContainPoint = function coordinatesContainPoint2(coordinates, point) {
  var contains = false;
  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
      contains = !contains;
    }
  }
  return contains;
};
var pointsEqual = function pointsEqual2(a, b) {
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};
var arrayIntersectsArray = function arrayIntersectsArray2(a, b) {
  for (var i = 0; i < a.length - 1; i++) {
    for (var j = 0; j < b.length - 1; j++) {
      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
        return true;
      }
    }
  }
  return false;
};
var closeRing = function closeRing2(coordinates) {
  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
    coordinates.push(coordinates[0]);
  }
  return coordinates;
};
var ringIsClockwise = function ringIsClockwise2(ringToTest) {
  var total = 0;
  var i = 0;
  var rLength = ringToTest.length;
  var pt1 = ringToTest[i];
  var pt2;
  for (i; i < rLength - 1; i++) {
    pt2 = ringToTest[i + 1];
    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
    pt1 = pt2;
  }
  return total >= 0;
};
var shallowClone = function shallowClone2(obj) {
  var target = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      target[i] = obj[i];
    }
  }
  return target;
};
var coordinatesContainCoordinates = function coordinatesContainCoordinates2(outer, inner) {
  var intersects = arrayIntersectsArray(outer, inner);
  var contains = coordinatesContainPoint(outer, inner[0]);
  if (!intersects && contains) {
    return true;
  }
  return false;
};
var convertRingsToGeoJSON = function convertRingsToGeoJSON2(rings) {
  var outerRings = [];
  var holes = [];
  var x;
  var outerRing;
  var hole;
  for (var r = 0; r < rings.length; r++) {
    var ring = closeRing(rings[r].slice(0));
    if (ring.length < 4) {
      continue;
    }
    if (ringIsClockwise(ring)) {
      var polygon = [ring.slice().reverse()];
      outerRings.push(polygon);
    } else {
      holes.push(ring.slice().reverse());
    }
  }
  var uncontainedHoles = [];
  while (holes.length) {
    hole = holes.pop();
    var contained = false;
    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];
      if (coordinatesContainCoordinates(outerRing, hole)) {
        outerRings[x].push(hole);
        contained = true;
        break;
      }
    }
    if (!contained) {
      uncontainedHoles.push(hole);
    }
  }
  while (uncontainedHoles.length) {
    hole = uncontainedHoles.pop();
    var intersects = false;
    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];
      if (arrayIntersectsArray(outerRing, hole)) {
        outerRings[x].push(hole);
        intersects = true;
        break;
      }
    }
    if (!intersects) {
      outerRings.push([hole.reverse()]);
    }
  }
  if (outerRings.length === 1) {
    return {
      type: "Polygon",
      coordinates: outerRings[0]
    };
  } else {
    return {
      type: "MultiPolygon",
      coordinates: outerRings
    };
  }
};
var getId = function getId2(attributes, idAttribute) {
  var keys = idAttribute ? [idAttribute, "OBJECTID", "FID"] : ["OBJECTID", "FID"];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key in attributes && (typeof attributes[key] === "string" || typeof attributes[key] === "number")) {
      return attributes[key];
    }
  }
  throw Error("No valid id attribute found");
};
var arcgisToGeoJSON = function arcgisToGeoJSON2(arcgis, idAttribute) {
  var geojson = {};
  if (arcgis.features) {
    geojson.type = "FeatureCollection";
    geojson.features = [];
    for (var i = 0; i < arcgis.features.length; i++) {
      geojson.features.push(arcgisToGeoJSON2(arcgis.features[i], idAttribute));
    }
  }
  if (typeof arcgis.x === "number" && typeof arcgis.y === "number") {
    geojson.type = "Point";
    geojson.coordinates = [arcgis.x, arcgis.y];
    if (typeof arcgis.z === "number") {
      geojson.coordinates.push(arcgis.z);
    }
  }
  if (arcgis.points) {
    geojson.type = "MultiPoint";
    geojson.coordinates = arcgis.points.slice(0);
  }
  if (arcgis.paths) {
    if (arcgis.paths.length === 1) {
      geojson.type = "LineString";
      geojson.coordinates = arcgis.paths[0].slice(0);
    } else {
      geojson.type = "MultiLineString";
      geojson.coordinates = arcgis.paths.slice(0);
    }
  }
  if (arcgis.rings) {
    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
  }
  if (typeof arcgis.xmin === "number" && typeof arcgis.ymin === "number" && typeof arcgis.xmax === "number" && typeof arcgis.ymax === "number") {
    geojson.type = "Polygon";
    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
  }
  if (arcgis.geometry || arcgis.attributes) {
    geojson.type = "Feature";
    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON2(arcgis.geometry) : null;
    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;
    if (arcgis.attributes) {
      try {
        geojson.id = getId(arcgis.attributes, idAttribute);
      } catch (err) {
      }
    }
  }
  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
    geojson.geometry = null;
  }
  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
    console.warn("Object converted in non-standard crs - " + JSON.stringify(arcgis.spatialReference));
  }
  return geojson;
};
var orientRings = function orientRings2(poly) {
  var output = [];
  var polygon = poly.slice(0);
  var outerRing = closeRing(polygon.shift().slice(0));
  if (outerRing.length >= 4) {
    if (!ringIsClockwise(outerRing)) {
      outerRing.reverse();
    }
    output.push(outerRing);
    for (var i = 0; i < polygon.length; i++) {
      var hole = closeRing(polygon[i].slice(0));
      if (hole.length >= 4) {
        if (ringIsClockwise(hole)) {
          hole.reverse();
        }
        output.push(hole);
      }
    }
  }
  return output;
};
var flattenMultiPolygonRings = function flattenMultiPolygonRings2(rings) {
  var output = [];
  for (var i = 0; i < rings.length; i++) {
    var polygon = orientRings(rings[i]);
    for (var x = polygon.length - 1; x >= 0; x--) {
      var ring = polygon[x].slice(0);
      output.push(ring);
    }
  }
  return output;
};
var geojsonToArcGIS = function geojsonToArcGIS2(geojson, idAttribute) {
  idAttribute = idAttribute || "OBJECTID";
  var spatialReference = {
    wkid: 4326
  };
  var result = {};
  var i;
  switch (geojson.type) {
    case "Point":
      result.x = geojson.coordinates[0];
      result.y = geojson.coordinates[1];
      if (geojson.coordinates[2] != null) {
        result.z = geojson.coordinates[2];
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiPoint":
      result.points = geojson.coordinates.slice(0);
      if (geojson.coordinates[0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "LineString":
      result.paths = [geojson.coordinates.slice(0)];
      if (geojson.coordinates[0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiLineString":
      result.paths = geojson.coordinates.slice(0);
      if (geojson.coordinates[0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "Polygon":
      result.rings = orientRings(geojson.coordinates.slice(0));
      if (geojson.coordinates[0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiPolygon":
      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));
      if (geojson.coordinates[0][0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "Feature":
      if (geojson.geometry) {
        result.geometry = geojsonToArcGIS2(geojson.geometry, idAttribute);
      }
      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};
      if (geojson.id) {
        result.attributes[idAttribute] = geojson.id;
      }
      break;
    case "FeatureCollection":
      result = [];
      for (i = 0; i < geojson.features.length; i++) {
        result.push(geojsonToArcGIS2(geojson.features[i], idAttribute));
      }
      break;
    case "GeometryCollection":
      result = [];
      for (i = 0; i < geojson.geometries.length; i++) {
        result.push(geojsonToArcGIS2(geojson.geometries[i], idAttribute));
      }
      break;
  }
  return result;
};
export {
  arcgisToGeoJSON,
  geojsonToArcGIS
};
/*! Bundled license information:

@terraformer/arcgis/dist/t-arcgis.esm.js:
  (* @preserve
  * @terraformer/arcgis - v2.1.1 - MIT
  * Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.
  * Tue Aug 02 2022 14:23:48 GMT-0700 (Pacific Daylight Time)
  *)
*/
//# sourceMappingURL=@terraformer_arcgis.js.map
